/**
 * Description: Helper functions for command-plugins (and, perhaps others).
 * Version:  $Id: command_plugins.c 190 2004-06-10 09:09:39Z romland $
 * License:  (c)2004 Joakim Romland, see doc/License
 */

# include "../include/www.h"

private mapping commands;


static void create()
{
	commands = ([ ]);
}

static int commandcount()
{
	return (commands ? map_sizeof(commands) : 0);
}


static int is_tool(object obj)
{
	object tool;
	mixed *arr;
	int i;

	if(!obj->lwoid()) {
		return FALSE;
	}

	arr = map_indices(commands);
	for(i = 0; i < sizeof(arr); i++) {
		tool = commands[arr[i]][HT_CMD_PRG];
		if(tool->lwoid() == obj->lwoid()) {
			return TRUE;
		}
	}
	return FALSE;
}


/**
 * Name: clone_tools()
 * Desc: Get instances of objects that provide methods we should know about.
 * Note: Only server can provide these tools.
 * Args: string *tools;
 * Rets: n/a
 */
static void clone_tools()
{
	int i, j;
	object *programs, ob;
	mapping map;
	mixed arr;

	programs = find_object(HTTP_SERVER)->get_plugins();

	commands = ([ ]);
	for(i = 0; i < sizeof(programs); i++) {
		ob = programs[i];
		map = ob->get_plugin_methods();
		if(!map) {
			continue;
		}
		arr = map_indices(map);
		for(j = 0; j < sizeof(arr); j++) {
			map[arr[j]][HT_CMD_PRG] = ob;
		}
		commands += map;
	}
}


/**
 * Name: get_plugin()
 * Desc: Internal function for mapping a method to an object.
 * Note: 
 * Args: command such as GET/POST
 * Rets: array with object/function (see defines: HT_CMD_...).
 */
private mixed *get_plugin(string cmd)
{
	return commands[cmd];
}


/*
 * TODO: We should make this function a bit more flexible to allow for multiple
 * plugins to be called when one method is used. Eg, OPTIONS: WebDAV will
 * want to add a DAV-header to the response generated by the HTTP command.
 * (as an example).
 */
static int call_method(object request, object response)
{
	string  cmd;
	mixed   *ext;
	ext = get_plugin(cmd = request->get_command());
	if(ext && sizeof(ext)) {
		if(!call_other(ext[HT_CMD_PRG], ext[HT_CMD_FN], request, response)) {
			return TRUE;
		}
	} else {
		return FALSE;
	}
	return TRUE;
}

